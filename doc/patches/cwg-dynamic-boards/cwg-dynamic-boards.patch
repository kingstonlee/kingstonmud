diff -BbuprN -x '*.o' src/act.comm.c src-patched/act.comm.c
--- src/act.comm.c	2004-05-27 21:36:14.000000000 -0400
+++ src-patched/act.comm.c	2004-07-19 22:19:00.000000000 -0400
@@ -22,6 +22,7 @@
 #include "improved-edit.h"
 #include "dg_scripts.h"
 #include "spells.h"
+#include "boards.h"
 
 /* local functions */
 void perform_tell(struct char_data *ch, struct char_data *vict, char *arg);
@@ -30,6 +31,7 @@ ACMD(do_say);
 ACMD(do_gsay);
 ACMD(do_tell);
 ACMD(do_reply);
+ACMD(do_respond);
 ACMD(do_spec_comm);
 ACMD(do_write);
 ACMD(do_page);
@@ -357,10 +359,32 @@ ACMD(do_spec_comm)
  */
 ACMD(do_write)
 {
-  struct obj_data *paper, *pen = NULL;
+  extern struct index_data *obj_index;
+  struct obj_data *paper, *pen = NULL, *obj;
   char *papername, *penname;
   char buf1[MAX_STRING_LENGTH], buf2[MAX_STRING_LENGTH];
 
+  /* before we do anything, lets see if there's a board involved. */
+  for (obj = ch->carrying; obj;obj=obj->next_content) {
+    if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+      break;
+    }
+  }
+  
+  if(!obj) {
+    for (obj = world[ch->in_room].contents; obj;obj=obj->next_content) {
+      if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+	break;
+      }
+    }
+  }
+  
+  if(obj) {                /* then there IS a board! */
+    write_board_message(GET_OBJ_VNUM(obj),ch,argument);
+    act ("$n begins to write a note on $p.", TRUE, ch, obj, 0, TO_ROOM);
+    return;
+  }
+  
   papername = buf1;
   penname = buf2;
 
@@ -642,3 +666,46 @@ ACMD(do_qcomm)
 	act(buf, 0, ch, 0, i->character, TO_VICT | TO_SLEEP);
   }
 }
+
+ACMD(do_respond) {
+  int found=0,mnum=0;
+  struct obj_data *obj;
+  char number[MAX_STRING_LENGTH];
+  
+  if(IS_NPC(ch)) {
+    send_to_char(ch,"As a mob, you never bothered to learn to read or write.\r\n");
+    return;
+  }
+  
+  for (obj = ch->carrying; obj;obj=obj->next_content) {
+    if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+      found=1;
+      break;
+    }
+  }
+  if(!obj) {
+    for (obj = world[ch->in_room].contents; obj;obj=obj->next_content) {
+      if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+	found=1;
+	break;
+      }
+    }
+  }
+  if (obj) {
+    argument = one_argument(argument, number);
+    if (!*number) {
+      send_to_char(ch,"Respond to what?\r\n");
+      return;
+    }
+    if (!isdigit(*number) || (!(mnum = atoi(number)))) {
+      send_to_char(ch,"You must type the number of the message you wish to reply to.\r\n");
+      return;
+    }
+    board_respond(GET_OBJ_VNUM(obj), ch, mnum);
+  }
+  
+  /* No board in the room? Send generic message -spl */
+  if (found == 0) {
+    send_to_char(ch,"Sorry, you may only reply to messages posted on a board.\r\n");
+  }
+}
diff -BbuprN -x '*.o' src/act.informative.c src-patched/act.informative.c
--- src/act.informative.c	2004-07-16 23:38:51.000000000 -0400
+++ src-patched/act.informative.c	2004-07-19 22:19:00.000000000 -0400
@@ -21,6 +21,7 @@
 #include "screen.h"
 #include "constants.h"
 #include "dg_scripts.h"
+#include "boards.h"
 
 /* extern variables */
 extern int top_of_helpt;
@@ -96,7 +97,7 @@ void look_in_direction(struct char_data 
 void look_in_obj(struct char_data *ch, char *arg);
 void look_out_window(struct char_data *ch, char *arg);
 char *find_exdesc(char *word, struct extra_descr_data *list);
-void look_at_target(struct char_data *ch, char *arg);
+void look_at_target(struct char_data *ch, char *arg, int read);
 void search_in_direction(struct char_data * ch, int dir);
 ACMD(do_autoexit);
 void do_auto_exits(room_rnum target_room, struct char_data *ch, int exit_mode);
@@ -165,6 +166,10 @@ void show_obj_to_char(struct obj_data *o
 	send_to_char(ch, "It's blank.\r\n");
       return;
 
+    case ITEM_BOARD:
+      show_board(GET_OBJ_VNUM(obj),ch);
+      break;
+      
     case ITEM_DRINKCON:
       send_to_char(ch, "It looks like a drink container.\r\n");
       break;
@@ -830,12 +835,13 @@ char *find_exdesc(char *word, struct ext
  * Thanks to Angus Mezick <angus@EDGIL.CCMAIL.COMPUSERVE.COM> for the
  * suggested fix to this problem.
  */
-void look_at_target(struct char_data *ch, char *arg)
+void look_at_target(struct char_data *ch, char *arg, int read)
 {
-  int bits, found = FALSE, j, fnum, i = 0;
+  int bits, found = FALSE, j, fnum, i = 0, msg = 1;
   struct char_data *found_char = NULL;
   struct obj_data *obj, *found_obj = NULL;
   char *desc;
+  char number[MAX_STRING_LENGTH];
 
   if (!ch->desc)
     return;
@@ -845,6 +851,44 @@ void look_at_target(struct char_data *ch
     return;
   }
 
+  if (read) {
+    for (obj = ch->carrying; obj;obj=obj->next_content) {
+      if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+	found = TRUE;
+	break;
+      }
+    }
+    if(!obj) {
+      for (obj = world[ch->in_room].contents; obj;obj=obj->next_content) {
+	if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+	  found = TRUE;
+	  break;
+	}
+      }
+    }
+    if (obj) {
+      arg = one_argument(arg, number);
+      if (!*number) {
+	send_to_char(ch,"Read what?\r\n");
+	return;
+      }
+      
+      /* Okay, here i'm faced with the fact that the person could be
+	 entering in something like 'read 5' or 'read 4.mail' .. so, whats the
+	 difference between the two?  Well, there's a period in the second,
+	 so, we'll just stick with that basic difference */
+      
+      if (isname(number, obj->name)) {
+	show_board(GET_OBJ_VNUM(obj), ch);
+      } else if ((!isdigit(*number) || (!(msg = atoi(number)))) ||
+		 (strchr(number,'.'))) {
+	sprintf(arg,"%s %s", number,arg);
+	look_at_target(ch, arg, 0);
+      } else {
+	board_display_msg(GET_OBJ_VNUM(obj), ch, msg);
+      }
+    }
+  } else {
   bits = generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_OBJ_EQUIP |
 		      FIND_CHAR_ROOM, ch, &found_char, &found_obj);
 
@@ -865,12 +909,6 @@ void look_at_target(struct char_data *ch
     return;
   }
 
-  /* Does the argument match an extra desc in the room? */
-  if ((desc = find_exdesc(arg, world[IN_ROOM(ch)].ex_description)) != NULL && ++i == fnum) {
-    page_string(ch->desc, desc, FALSE);
-    return;
-  }
-
   /* Does the argument match an extra desc in the char's equipment? */
   for (j = 0; j < NUM_WEARS && !found; j++)
     if (GET_EQ(ch, j) && CAN_SEE_OBJ(ch, GET_EQ(ch, j)))
@@ -886,10 +924,14 @@ void look_at_target(struct char_data *ch
   for (obj = ch->carrying; obj && !found; obj = obj->next_content) {
     if (CAN_SEE_OBJ(ch, obj))
       if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum) {
+	if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+	  show_board(GET_OBJ_VNUM(obj), ch);
+	} else {
 	send_to_char(ch, "%s", desc);
         diag_obj_to_char(obj, ch);
         send_to_char(ch, "It appears to be made of %s.\r\n",
          material_names[GET_OBJ_MATERIAL(obj)]);
+	}
 	found = TRUE;
       }
   }
@@ -898,10 +940,14 @@ void look_at_target(struct char_data *ch
   for (obj = world[IN_ROOM(ch)].contents; obj && !found; obj = obj->next_content)
     if (CAN_SEE_OBJ(ch, obj))
       if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum) {
+	if(GET_OBJ_TYPE(obj) == ITEM_BOARD) {
+	  show_board(GET_OBJ_VNUM(obj), ch);
+	} else {
 	send_to_char(ch, "%s", desc);
         diag_obj_to_char(obj, ch);
         send_to_char(ch, "It appears to be made of %s.\r\n",
          material_names[GET_OBJ_MATERIAL(obj)]);
+	}
 	found = TRUE;
       }
 
@@ -915,6 +961,7 @@ void look_at_target(struct char_data *ch
     }
   } else if (!found)
     send_to_char(ch, "You do not see that here.\r\n");
+  }
 }
 
 void look_out_window(struct char_data *ch, char *arg)
@@ -1010,7 +1057,7 @@ ACMD(do_look)
       if (!*arg)
 	send_to_char(ch, "Read what?\r\n");
       else
-	look_at_target(ch, arg);
+	look_at_target(ch, arg, 1);
       return;
     }
     argument = any_one_arg(argument, arg);
@@ -1055,14 +1102,14 @@ ACMD(do_look)
       if (subcmd == SCMD_SEARCH)
         send_to_char(ch, "That is not a direction!\r\n");
       else
-      look_at_target(ch, arg2);
+      look_at_target(ch, arg2, 0);
     } else if (find_exdesc(arg, world[IN_ROOM(ch)].ex_description) != NULL) {
-      look_at_target(ch, arg);
+      look_at_target(ch, arg, 0);
     } else {
       if (subcmd == SCMD_SEARCH)
         send_to_char(ch, "That is not a direction!\r\n");
     else
-      look_at_target(ch, arg);
+      look_at_target(ch, arg, 0);
   }
   }
 }
@@ -1083,7 +1130,7 @@ ACMD(do_examine)
   }
 
   /* look_at_target() eats the number. */
-  look_at_target(ch, strcpy(tempsave, arg));	/* strcpy: OK */
+  look_at_target(ch, strcpy(tempsave, arg),0);	/* strcpy: OK */
 
   generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_CHAR_ROOM |
 		      FIND_OBJ_EQUIP, ch, &tmp_char, &tmp_object);
diff -BbuprN -x '*.o' src/act.item.c src-patched/act.item.c
--- src/act.item.c	2004-05-27 21:36:14.000000000 -0400
+++ src-patched/act.item.c	2004-07-19 22:19:00.000000000 -0400
@@ -23,6 +23,7 @@
 #include "dg_scripts.h"
 #include "oasis.h"
 #include "assemblies.h"
+#include "boards.h"
 
 /* extern functions */
 char *find_exdesc(char *word, struct extra_descr_data *list);
@@ -1680,8 +1681,9 @@ void perform_remove(struct char_data *ch
 
 ACMD(do_remove)
 {
+  struct obj_data *obj;
   char arg[MAX_INPUT_LENGTH];
-  int i, dotmode, found;
+  int i, dotmode, found = 0, msg;
 
   one_argument(argument, arg);
 
@@ -1689,37 +1691,67 @@ ACMD(do_remove)
     send_to_char(ch, "Remove what?\r\n");
     return;
   }
+  /* lemme check for a board FIRST */
+  for (obj = ch->carrying; obj; obj = obj->next_content) {
+    if (GET_OBJ_TYPE (obj) == ITEM_BOARD) {
+      found = 1;
+      break;
+    }
+  }
+  if (!obj) {
+    for (obj = world[ch->in_room].contents; obj; obj = obj->next_content) {
+      if (GET_OBJ_TYPE (obj) == ITEM_BOARD) {
+	found = 1;
+	break;
+      }
+    }
+  }
+
+  if (found) {
+    if (!isdigit (*arg) || (!(msg = atoi (arg)))) {
+      found = 0;
+    } else {
+      remove_board_msg (GET_OBJ_VNUM (obj), ch, msg);
+    }
+  }
+  if (!found) {
   dotmode = find_all_dots(arg);
 
   if (dotmode == FIND_ALL) {
     found = 0;
-    for (i = 0; i < NUM_WEARS; i++)
+      for (i = 0; i < NUM_WEARS; i++) {
       if (GET_EQ(ch, i)) {
 	perform_remove(ch, i);
 	found = 1;
       }
-    if (!found)
+      }
+      if (!found) {
       send_to_char(ch, "You're not using anything.\r\n");
+      }
   } else if (dotmode == FIND_ALLDOT) {
-    if (!*arg)
+      if (!*arg) {
       send_to_char(ch, "Remove all of what?\r\n");
-    else {
+      } else {
       found = 0;
-      for (i = 0; i < NUM_WEARS; i++)
+	for (i = 0; i < NUM_WEARS; i++) {
 	if (GET_EQ(ch, i) && CAN_SEE_OBJ(ch, GET_EQ(ch, i)) &&
 	    isname(arg, GET_EQ(ch, i)->name)) {
 	  perform_remove(ch, i);
 	  found = 1;
 	}
-      if (!found)
+	}
+	if (!found) {
 	send_to_char(ch, "You don't seem to be using any %ss.\r\n", arg);
     }
+      }
   } else {
-    if ((i = get_obj_pos_in_equip_vis(ch, arg, NULL, ch->equipment)) < 0)
+      if ((i = get_obj_pos_in_equip_vis(ch, arg, NULL, ch->equipment)) < 0) {
       send_to_char(ch, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
-    else
+      } else {
       perform_remove(ch, i);
   }
+    }
+  }
 }
 
 ACMD(do_sac) 
diff -BbuprN -x '*.o' src/act.other.c src-patched/act.other.c
--- src/act.other.c	2004-07-16 23:38:51.000000000 -0400
+++ src-patched/act.other.c	2004-07-19 22:24:23.000000000 -0400
@@ -928,7 +928,9 @@ ACMD(do_gen_tog)
     {"Autosplit disabled.\r\n",
     "Autosplit enabled.\r\n"},
     {"Autosac disabled.\r\n",
-    "Autosac enabled.\r\n"}
+     "Autosac enabled.\r\n"},
+    {"Viewing newest board messages first.\r\n",
+     "Viewing eldest board messages first.  Wierdo.\r\n"}
   };
 
 
@@ -1026,6 +1028,9 @@ ACMD(do_gen_tog)
   case SCMD_AUTOSAC: 
     result = PRF_TOG_CHK(ch, PRF_AUTOSAC); 
     break; 
+  case SCMD_VIEWORDER:
+    result = PRF_TOG_CHK(ch, PRF_VIEWORDER);
+    break;
   default:
     log("SYSERR: Unknown subcmd %d in do_gen_toggle.", subcmd);
     return;
diff -BbuprN -x '*.o' src/boards.c src-patched/boards.c
--- src/boards.c	2004-01-18 19:20:47.000000000 -0500
+++ src-patched/boards.c	2004-07-20 18:18:10.000000000 -0400
@@ -47,6 +47,8 @@ TO ADD A NEW BOARD, simply follow our ea
 #include "conf.h"
 #include "sysdep.h"
 
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include "structs.h"
 #include "utils.h"
@@ -57,494 +59,752 @@ TO ADD A NEW BOARD, simply follow our ea
 #include "handler.h"
 #include "improved-edit.h"
 
-/* Board appearance order. */
-#define	NEWEST_AT_TOP	FALSE
+struct board_info *bboards=NULL;  /* our global board structure */
 
-/*
-format:	vnum, read lvl, write lvl, remove lvl, filename, 0 at end
-Be sure to also change NUM_OF_BOARDS in board.h
-*/
-struct board_info_type board_info[NUM_OF_BOARDS] = {
-  {3099, 0, 0, LVL_GOD, LIB_ETC "board.mort", 0},
-  {3098, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC "board.immort", 0},
-  {3097, LVL_IMMORT, LVL_FREEZE, LVL_IMPL, LIB_ETC "board.freeze", 0},
-  {3096, 0, 0, LVL_IMMORT, LIB_ETC "board.social", 0},
-};
-
-/* local functions */
-SPECIAL(gen_board);
-int find_slot(void);
-int find_board(struct char_data *ch);
-void init_boards(void);
-
-char *msg_storage[INDEX_SIZE];
-int msg_storage_taken[INDEX_SIZE];
-int num_of_msgs[NUM_OF_BOARDS];
-int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;
-struct board_msginfo msg_index[NUM_OF_BOARDS][MAX_BOARD_MESSAGES];
+extern struct descriptor_data *descriptor_list;
+extern struct index_data *obj_index;
 
+void init_boards(void) {
+  int i,j,board_vnum;
+  struct xap_dir xd;
+  struct board_info *tmp_board;
 
-int find_slot(void)
-{
-  int i;
+  if(!insure_directory(BOARD_DIRECTORY,0)) {
+    log("Unable to open/create directory '%s' - Exiting", BOARD_DIRECTORY);
+    exit(1);
+  }
+  
+  if((i=xdir_scan(BOARD_DIRECTORY,&xd)) <= 0) {
+    log("Funny, no board files found.\n");
+    return;
+  }
 
-  for (i = 0; i < INDEX_SIZE; i++)
-    if (!msg_storage_taken[i]) {
-      msg_storage_taken[i] = 1;
-      return (i);
+  /* otherwise they do exist */
+  for(j=0;j < i; j++) {
+    if(strcmp("..",xdir_get_name(&xd,j)) &&
+       strcmp(".",xdir_get_name(&xd,j))) {
+      sscanf(xdir_get_name(&xd,j),"%d", &board_vnum);
+      if((tmp_board = load_board(board_vnum)) != NULL) {
+	tmp_board->next = bboards;
+	bboards = tmp_board;
+      }
     }
-  return (-1);
+  }
+  /* just logs some summary data about the boards */
+  look_at_boards();
 }
 
+struct board_info *create_new_board(int board_vnum) {
+  char buf[512];
+  FILE *fl;
+  struct board_info *temp=NULL,*backup;
+  struct obj_data *obj=NULL;
+  
+  /* object exists, but no board file (yet) */
 
-/* search the room ch is standing in to find which board he's looking at */
-int find_board(struct char_data *ch)
-{
-  struct obj_data *obj;
-  int i;
+  if((fl = fopen(buf, "r"))) {
+    fclose(fl);
+    log("Preexisting board file when attempting to create new board [vnum: %d]. Attempting to correct.", board_vnum);
 
-  for (obj = world[IN_ROOM(ch)].contents; obj; obj = obj->next_content)
-    for (i = 0; i < NUM_OF_BOARDS; i++)
-      if (BOARD_RNUM(i) == GET_OBJ_RNUM(obj))
-	return (i);
+    /* unlink file, clear existing board */
+    unlink(buf);
 
-  if (GET_LEVEL(ch) >= LVL_IMMORT)
-    for (obj = ch->carrying; obj; obj = obj->next_content)
-      for (i = 0; i < NUM_OF_BOARDS; i++)
-        if (BOARD_RNUM(i) == GET_OBJ_RNUM(obj))
-          return (i);
+    for(temp = bboards,backup=NULL; temp && !backup; temp = temp->next) {
+      if(BOARD_VNUM(temp) == board_vnum) {
+	backup = temp;
+      }
+    }
+    if(backup) {
+      REMOVE_FROM_LIST(backup, bboards, next);
+      clear_one_board(backup);
+    }
+  }
+  CREATE(temp, struct board_info, 1);
+  if(real_object(board_vnum) == NOTHING) {
+    log("Creating board [vnum: %d] though no associated object with that vnum can be found. Using defaults.",board_vnum);
+    READ_LVL(temp)=LVL_IMMORT;
+    WRITE_LVL(temp)=LVL_IMMORT;
+    REMOVE_LVL(temp)=LVL_IMMORT;
+    } else {
+      obj = &(obj_proto[real_object(board_vnum)]);
+      READ_LVL(temp)=GET_OBJ_VAL(obj, 0);
+      WRITE_LVL(temp)=GET_OBJ_VAL(obj, 1);
+      REMOVE_LVL(temp)=GET_OBJ_VAL(obj, 2);
+    }
+  BOARD_VNUM(temp)=board_vnum;
+  BOARD_MNUM(temp)=0;
+  temp->next=NULL;
+  BOARD_MESSAGES(temp)=NULL;
 
-  return (-1);
+  if(!save_board(temp)) {
+    log("Hm. Error while creating new board file [vnum: %d]. Unable to create new file.",board_vnum);
+    free(temp);
+    return NULL;
+  }
+  return temp;
 }
 
+int save_board(struct board_info *ts) {
+  struct board_msg *message;
+  struct board_memory *memboard;
+  FILE *fl;
+  char buf[512];
+  int i=1;
+  sprintf(buf,"%s/%d",BOARD_DIRECTORY,BOARD_VNUM(ts));
+  
+  if(!(fl = fopen(buf,"wb"))) {
+    log("Hm. Error while creating attempting to save board [vnum: %d].  Unable to create file '%s'",BOARD_VNUM(ts),buf);
+    return 0;
+  }
+  fprintf(fl,"Board File\n%d %d %d %d\n",READ_LVL(ts),
+	  WRITE_LVL(ts), REMOVE_LVL(ts), BOARD_MNUM(ts));
+  
+  for(message=BOARD_MESSAGES(ts);message;message=MESG_NEXT(message)) {
+    fprintf(fl,"#%d\n"
+	    "%ld\n"
+	    "%ld\n"
+	    "%s\n"
+	    "%s~\n",
+	    i++, MESG_POSTER(message), MESG_TIMESTAMP(message),
+	    MESG_SUBJECT(message), MESG_DATA(message));
+  }
+  /* now write out the saved info.. */
+  for(i=0;i!=301;i++) {
+    memboard=BOARD_MEMORY(ts,i);
+    while(memboard) {
+      fprintf(fl,"S%d %d %d\n",i, MEMORY_READER(memboard),
+	      +             MEMORY_TIMESTAMP(memboard));
+      memboard=MEMORY_NEXT(memboard);
+    }
+  }
+  fclose(fl);
+  return 1;
+}
 
-void init_boards(void)
-{
-  int i, j, fatal_error = 0;
+/* a fairly messy function                         */
+/* see accompanying document for board file format */
 
-  for (i = 0; i < INDEX_SIZE; i++) {
-    msg_storage[i] = 0;
-    msg_storage_taken[i] = 0;
-  }
+struct board_info *load_board(int board_vnum) {
+  struct board_info *temp_board;
+  struct board_msg *bmsg;
+  struct obj_data *obj=NULL;
+  struct stat st;
+  struct board_memory *memboard, *list;
+  int t[4], mnum, poster,timestamp, msg_num;
+  char filebuf[512],buf[512];
+  FILE *fl;
+  int sflag, error_flag = 0;
 
-  for (i = 0; i < NUM_OF_BOARDS; i++) {
-    if ((BOARD_RNUM(i) = real_object(BOARD_VNUM(i))) == NOTHING) {
-      log("SYSERR: Fatal board error: board vnum %d does not exist!",
-	      BOARD_VNUM(i));
-      fatal_error = 1;
+  sprintf(filebuf,"%s/%d", BOARD_DIRECTORY,board_vnum);
+  if(!(fl=fopen(filebuf,"r"))) {
+    log("Request to open board [vnum %d] failed - unable to open file '%s'.",board_vnum,filebuf);
+    return NULL;
+  }
+  /* this won't be the most graceful thing you've ever seen .. */
+  get_line(fl,buf);
+  
+  if(strcasecmp("Board File",buf)) {
+    log("Invalid board file '%s' [vnum: %d] - failed to load.", filebuf,board_vnum);
+    return NULL;
+  }
+  
+  CREATE(temp_board, struct board_info, 1);
+  temp_board->vnum=board_vnum;
+  get_line(fl, buf);
+  /* oddly enough, most errors in board files can be ignored, setting defaults */
+  
+  if (sscanf(buf,"%d %d %d %d", t, t+1, t+2, t+3) != 4) {
+    log("Parse error on board [vnum: %d], file '%s' - attempting to correct.", board_vnum, filebuf);
+    t[0] = t[1] = t[2] = LVL_IMMORT;
+    t[3] = -1;
+    error_flag = 1;
+  }
+  /* if the objcet exists, the object trumps the board file settings */
+  
+  if(real_object(board_vnum) == NOTHING) {
+    log("No associated object exists when attempting to create a board [vnum %d].", board_vnum);
+    /* previously we just erased it, but lets do a tiny bit of checking, just in case           */
+    /* auto delete only if the file has hasn't been modified in the last 7 days */
+    
+    
+    stat(filebuf, &st);
+    if(time(NULL) - st.st_mtime > (60*60*24*7)) {
+      log("Deleting old board file '%s' [vnum %d].  7 days without modification & no associated object.", filebuf,board_vnum);
+      unlink(filebuf);
+      free(temp_board);
+      return NULL;
+    }
+    READ_LVL(temp_board)=t[0];
+    WRITE_LVL(temp_board)=t[1];
+    REMOVE_LVL(temp_board)=t[2];
+    BOARD_MNUM(temp_board)=t[3];
+  } else {
+    obj = &(obj_proto[real_object(board_vnum)]);
+    /* double check one or two things */
+    if(t[0] != GET_OBJ_VAL(obj,0) ||
+       t[1] != GET_OBJ_VAL(obj,1) ||
+       t[2] != GET_OBJ_VAL(obj,2)) {
+      log("Mismatch in board <-> object read/write/remove settings for board [vnum: %d]. Correcting.", board_vnum);
+      error_flag=1;
+    }
+    READ_LVL(temp_board)=GET_OBJ_VAL(obj, 0);
+    WRITE_LVL(temp_board)=GET_OBJ_VAL(obj, 1);
+    REMOVE_LVL(temp_board)=GET_OBJ_VAL(obj, 2);
+    BOARD_MNUM(temp_board)=t[3];
+  }
+  
+  BOARD_NEXT(temp_board)=NULL;
+  BOARD_MESSAGES(temp_board)=NULL;
+  
+  /* now loop and parse messages and memory */
+  msg_num = 0;
+  while(get_line(fl,buf)) {
+    if(*buf == 'S') {
+      if(sscanf(buf,"S %d %d %d ", &mnum, &poster, &timestamp) == 3) {
+	CREATE(memboard, struct board_memory, 1);
+	MEMORY_READER(memboard)=poster;
+	MEMORY_TIMESTAMP(memboard)=timestamp;
+	
+	/* now, validate the memory => insure that for this slot, id, and timestamp there
+	   is a valid message, and poster.  Memory is deleted for mundane reasons; character
+	   deletions, message deletions, etc.  'Failures' will not be logged */
+	
+	if(get_name_by_id(poster) == NULL) {
+	  free(memboard);
+	  error_flag = 1;
+	} else {
+	  /* locate specific message this pertains to - therefore, messages MUST be loaded first! */
+	  for(bmsg=BOARD_MESSAGES(temp_board), sflag=0; bmsg && !sflag; bmsg = MESG_NEXT(bmsg)) {
+	    if(MESG_TIMESTAMP(bmsg) == MEMORY_TIMESTAMP(memboard)
+	       && (mnum == ((MESG_TIMESTAMP(bmsg)%301 +
+			     MESG_POSTER(bmsg)%301)%301))) {
+	      sflag=1;
+	    }
+	  }
+	  
+	  if(sflag) {
+	    if(BOARD_MEMORY(temp_board,mnum)) {
+	      list=BOARD_MEMORY(temp_board,mnum);
+	      BOARD_MEMORY(temp_board,mnum)=memboard;
+	      MEMORY_NEXT(memboard)=list;
+	    } else {
+	      BOARD_MEMORY(temp_board,mnum)=memboard;
+	      MEMORY_NEXT(memboard)=NULL;
+	    }
+	  } else {
+	    free(memboard);
+	  }
+	}
+      } else {
+	error_flag=1;
+      }
+    } else if (*buf == '#') {
+      if(parse_message(fl, temp_board)) {
+	msg_num++;
     }
-    num_of_msgs[i] = 0;
-    for (j = 0; j < MAX_BOARD_MESSAGES; j++) {
-      memset((char *) &(msg_index[i][j]), 0, sizeof(struct board_msginfo));
-      msg_index[i][j].slot_num = -1;
     }
-    Board_load_board(i);
   }
 
-  if (fatal_error)
-    exit(1);
-}
-
-
-SPECIAL(gen_board)
-{
-  int board_type;
-  static int loaded = 0;
-  struct obj_data *board = (struct obj_data *)me;
-
-  if (!loaded) {
-    init_boards();
-    loaded = 1;
-  }
-  if (!ch->desc)
-    return (0);
-
-  ACMD_READ = find_command("read");
-  ACMD_WRITE = find_command("write");
-  ACMD_REMOVE = find_command("remove");
-  ACMD_LOOK = find_command("look");
-  ACMD_EXAMINE = find_command("examine");
-
-  if (cmd != ACMD_WRITE && cmd != ACMD_LOOK && cmd != ACMD_EXAMINE &&
-      cmd != ACMD_READ && cmd != ACMD_REMOVE)
-    return (0);
-
-  if ((board_type = find_board(ch)) == -1) {
-    log("SYSERR:  degenerate board!  (what the hell...)");
-    return (0);
-  }
-  if (cmd == ACMD_WRITE)
-    return (Board_write_message(board_type, ch, argument, board));
-  else if (cmd == ACMD_LOOK || cmd == ACMD_EXAMINE)
-    return (Board_show_board(board_type, ch, argument, board));
-  else if (cmd == ACMD_READ)
-    return (Board_display_msg(board_type, ch, argument, board));
-  else if (cmd == ACMD_REMOVE)
-    return (Board_remove_msg(board_type, ch, argument, board));
-  else
-    return (0);
+  /* now we've completely parsed our file */
+  fclose(fl);
+  if(msg_num != BOARD_MNUM(temp_board)) {
+    log("Board [vnum: %d] message count (%d) not equal to actual message count (%d). Correcting.",
+	BOARD_VNUM(temp_board),BOARD_MNUM(temp_board),msg_num);
+    BOARD_MNUM(temp_board) = msg_num;
+    error_flag = 1;
+  }
+  /* if the error flag is set, we need to save the board again */
+  if(error_flag) {
+    save_board(temp_board);
+  }
+  return temp_board;
 }
 
+int parse_message(FILE *fl, struct board_info *temp_board) {
+  struct board_msg *tmsg, *t2msg;
+  char subject[81];
+  char buf[MAX_MESSAGE_LENGTH + 1];
+  /* arbitrairy max message length */
 
-int Board_write_message(int board_type, struct char_data *ch, char *arg, struct obj_data *board)
-{
-  char *tmstr;
-  time_t ct;
-  char buf[MAX_INPUT_LENGTH], buf2[MAX_NAME_LENGTH + 3];
+  CREATE(tmsg, struct board_msg, 1);
 
-  if (GET_LEVEL(ch) < WRITE_LVL(board_type)) {
-    send_to_char(ch, "You are not holy enough to write on this board.\r\n");
-    return (1);
-  }
-  if (num_of_msgs[board_type] >= MAX_BOARD_MESSAGES) {
-    send_to_char(ch, "The board is full.\r\n");
-    return (1);
-  }
-  if ((NEW_MSG_INDEX(board_type).slot_num = find_slot()) == -1) {
-    send_to_char(ch, "The board is malfunctioning - sorry.\r\n");
-    log("SYSERR: Board: failed to find empty slot on write.");
-    return (1);
+  /* what about our error checking? */
+  if(fscanf(fl, "%ld\n", &(MESG_POSTER(tmsg))) != 1 ||
+     fscanf(fl, "%ld\n", &(MESG_TIMESTAMP(tmsg))) != 1 ) {
+    log("Parse error in message for board [vnum: %d].  Skipping.", BOARD_VNUM(temp_board));
+    free(tmsg);
+    return 0;
   }
-  /* skip blanks */
-  skip_spaces(&arg);
-  delete_doubledollar(arg);
+  get_line(fl,subject);
 
-  /* JE 27 Oct 95 - Truncate headline at 80 chars if it's longer than that */
-  arg[80] = '\0';
+  MESG_SUBJECT(tmsg)=strdup(subject);
+  MESG_DATA(tmsg)=fread_string(fl,buf);
+  MESG_NEXT(tmsg)=NULL;
 
-  if (!*arg) {
-    send_to_char(ch, "We must have a headline!\r\n");
-    return (1);
+  /* always add to the END of the list. */
+  MESG_NEXT(tmsg) = MESG_PREV(tmsg)= NULL;
+  if(BOARD_MESSAGES(temp_board)) {
+    t2msg=BOARD_MESSAGES(temp_board);
+    while(MESG_NEXT(t2msg)) {
+      t2msg = MESG_NEXT(t2msg);
   }
-  ct = time(0);
-  tmstr = (char *) asctime(localtime(&ct));
-  *(tmstr + strlen(tmstr) - 1) = '\0';
-
-  snprintf(buf2, sizeof(buf2), "(%s)", GET_NAME(ch));
-  snprintf(buf, sizeof(buf), "%6.10s %-12s :: %s", tmstr, buf2, arg);
-  NEW_MSG_INDEX(board_type).heading = strdup(buf);
-  NEW_MSG_INDEX(board_type).level = GET_LEVEL(ch);
+    MESG_NEXT(t2msg)=tmsg;
+    MESG_PREV(tmsg)=t2msg;
+  } else {
+    MESG_PREV(tmsg) = NULL;
+    BOARD_MESSAGES(temp_board) = tmsg;
+  }
+  return 1;
+}
 
-  send_to_char(ch, "Write your message.\r\n");
-  send_editor_help(ch->desc);
-  act("$n starts to write a message.", TRUE, ch, 0, 0, TO_ROOM);
+void look_at_boards() {
+  int counter, messages=0;
+  struct board_info *tboard=bboards;
+  struct board_msg *msg;
 
-  string_write(ch->desc, &(msg_storage[NEW_MSG_INDEX(board_type).slot_num]),
-		MAX_MESSAGE_LENGTH, board_type + BOARD_MAGIC, NULL);
+  for(counter=0;tboard;counter++) {
+    msg=BOARD_MESSAGES(tboard);
+    while(msg) {
+      messages++;
+      msg=MESG_NEXT(msg);
+    }
+    tboard=BOARD_NEXT(tboard);
+  }
+  log("There are %d boards located; %d messages",counter, messages);
+}
 
-  num_of_msgs[board_type]++;
-  return (1);
+void clear_boards() {
+  struct board_info *tmp, *tmp2;
+  for(tmp = bboards; tmp; tmp = tmp2) {
+    tmp2=tmp->next;
+    clear_one_board(tmp);
+  }
 }
 
 
-int Board_show_board(int board_type, struct char_data *ch, char *arg, struct obj_data *board)
-{
+void clear_one_board(struct board_info *tmp) {
+  struct board_msg *m1, *m2;
+  struct board_memory *mem1,*mem2;
   int i;
-  char tmp[MAX_STRING_LENGTH], buf[MAX_STRING_LENGTH];
 
-  if (!ch->desc)
-    return (0);
+  /* before we clear this board, we need to disconnect anyone writing/etc to it */
+  /* xapxapxap take care of this later */
 
-  one_argument(arg, tmp);
+  /* clear the messages */
+  for(m1 = BOARD_MESSAGES(tmp);m1; m1 = m2) {
+    m2 = m1->next;
+    free(m1->subject);
+    free(m1->data);
+    free(m1);
+  }
+  /* clear the memory */
+  for(i=0;i < 301; i++) {
+    for(mem1 = BOARD_MEMORY(tmp,i); mem1; mem1=mem2) {
+	  mem2=mem1->next;
+	  free(mem1);
+    }
+  }
+  free(tmp);
+  tmp=NULL;
+}
+
+void show_board(int board_vnum, struct char_data *ch) {
+  struct board_info *thisboard;
+  struct board_msg *message;
+  char *tmstr;
+  int msgcount=0,yesno=0;
+  char buf[MAX_STRING_LENGTH];
+  char name[127];
+  /* board locate */
+  if(IS_NPC(ch)) {
+    send_to_char(ch,"Gosh.. now .. if only mobs could read.. you'd be doing good.\r\n");
+    return;
+  }
+  thisboard = locate_board(board_vnum);
+  if (!thisboard) {
+    log("Creating new board - board #%d", board_vnum);
+    thisboard=create_new_board(board_vnum);
+    thisboard->next = bboards;
+    bboards = thisboard;
+  }
+  if (GET_LEVEL(ch) < READ_LVL(thisboard)) {
+    send_to_char(ch,"You try but fail to understand the holy words.\r\n");
+    return;
+  }
+  
+  /* send the standard board boilerplate */
 
-  if (!*tmp || !isname(tmp, board->name))
-    return (0);
+  sprintf(buf,"This is a bulletin board.\r\n"
+	  "Usage:READ/REMOVE <messg #>, RESPOND <messg #>, WRITE <header>.\r\n");
+  if (!BOARD_MNUM(thisboard) || !BOARD_MESSAGES(thisboard)) {
+    strcat(buf, "The board is empty.\r\n");
+    send_to_char(ch,buf);
+    return;
+  } else {
+    sprintf(buf, "%sThere %s %d %s on the board.\r\n",
+	    buf, (BOARD_MNUM(thisboard) == 1) ? "is" : "are",
+	    BOARD_MNUM(thisboard),(BOARD_MNUM(thisboard) == 1) ? "message" :
+	    "messages");
 
-  if (GET_LEVEL(ch) < READ_LVL(board_type)) {
-    send_to_char(ch, "You try but fail to understand the holy words.\r\n");
-    return (1);
   }
-  act("$n studies the board.", TRUE, ch, 0, 0, TO_ROOM);
+  message=BOARD_MESSAGES(thisboard);
+  if(PRF_FLAGGED(ch,PRF_VIEWORDER)) {
+    while(MESG_NEXT(message)) {
+      message = MESG_NEXT(message);
+    }
+  }
+  while (message) {
+    tmstr = (char *) asctime(localtime( &MESG_TIMESTAMP(message)));
+    *(tmstr + strlen(tmstr) - 1) = '\0';
+    yesno=mesglookup(message,ch,thisboard);
+    sprintf(name,"%s",get_name_by_id(MESG_POSTER(message)));
+    sprintf(buf+strlen(buf),"[%s] (%2d) : %6.10s (%-10s) :: %s \r\n",
+	    yesno ? "x" : " ",
+	    ++msgcount,
+	    tmstr,
+	    CAP(name),
+	    MESG_SUBJECT(message) ? MESG_SUBJECT(message) : "No Subject");
+    
+    if(PRF_FLAGGED(ch,PRF_VIEWORDER)) {
+      message=MESG_PREV(message);
+    } else {
+      message=MESG_NEXT(message);
+    }
+  }
+  page_string(ch->desc, buf, 1);
+  return;
 
-  if (!num_of_msgs[board_type])
-    send_to_char(ch, "This is a bulletin board.  Usage: READ/REMOVE <messg #>, WRITE <header>.\r\nThe board is empty.\r\n");
-  else {
-    size_t len = 0;
-    int nlen;
+}
 
-    len = snprintf(buf, sizeof(buf),
-		"This is a bulletin board.  Usage: READ/REMOVE <messg #>, WRITE <header>.\r\n"
-		"You will need to look at the board to save your message.\r\n"
-		"There are %d messages on the board.\r\n",
-		num_of_msgs[board_type]);
-#if NEWEST_AT_TOP
-    for (i = num_of_msgs[board_type] - 1; i >= 0; i--) {
-      if (!MSG_HEADING(board_type, i))
-        goto fubar;
+void board_display_msg(int board_vnum, struct char_data * ch, int arg) {
+  struct board_info *thisboard=bboards;
+  struct board_msg *message;
+  char *tmstr;
+  int msgcount,mem,sflag;
+  char name[127];
+  struct board_memory *mboard_type, *list;
+  char buf[MAX_STRING_LENGTH+1];
 
-      nlen = snprintf(buf + len, sizeof(buf) - len, "%-2d : %s\r\n", num_of_msgs[board_type] - i, MSG_HEADING(board_type, i));
-      if (len + nlen >= sizeof(buf) || nlen < 0)
-        break;
-      len += nlen;
+  if(IS_NPC(ch)) {
+    send_to_char(ch,"Silly mob - reading is for pcs!\r\n");
+    return;
+  }
+  /* guess we'll have to locate the board now in the list */
+  thisboard = locate_board(board_vnum);
+  if (!thisboard) {
+    log("Creating new board - board #%d", board_vnum);
+    thisboard=create_new_board(board_vnum);
     }
-#else
-    for (i = 0; i < num_of_msgs[board_type]; i++) {
-      if (!MSG_HEADING(board_type, i))
-        goto fubar;
 
-      nlen = snprintf(buf + len, sizeof(buf) - len, "%-2d : %s\r\n", i + 1, MSG_HEADING(board_type, i));
-      if (len + nlen >= sizeof(buf) || nlen < 0)
-        break;
-      len += nlen;
+  if (GET_LEVEL(ch) < READ_LVL(thisboard)) {
+    send_to_char(ch,"You try but fail to understand the holy words.\r\n");
+    return;
+    
     }
-#endif
-    page_string(ch->desc, buf, TRUE);
+  if (!BOARD_MESSAGES(thisboard)) {
+    send_to_char(ch,"The board is empty!\r\n");
+    return;
   }
-  return (1);
 
-fubar:
-  log("SYSERR: Board %d is fubar'd.", board_type);
-  send_to_char(ch, "Sorry, the board isn't working.\r\n");
-  return (1);
-}
+  /* now we locate the message.*/
+  message=BOARD_MESSAGES(thisboard);
+  if (arg < 1) {
+    send_to_char(ch,"You must specify the (positive) number of the message to be read!\r\n");
+    return;
+  }
+  for(msgcount=arg;message && msgcount!=1;msgcount--) {
+    message=MESG_NEXT(message);
+  }
 
+  if(!message) {
+    send_to_char(ch,"That message exists only in your imagination.\r\n");
+    return;
+  }	      /* Have message, let's add the fact that this player read the mesg */
 
-int Board_display_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board)
-{
-  char number[MAX_INPUT_LENGTH], buffer[MAX_STRING_LENGTH];
-  int msg, ind;
+  mem = ((MESG_TIMESTAMP(message)%301 + MESG_POSTER(message)%301)%301);
 
-  one_argument(arg, number);
-  if (!*number)
-    return (0);
-  if (isname(number, board->name))	/* so "read board" works */
-    return (Board_show_board(board_type, ch, arg, board));
-  if (!is_number(number))	/* read 2.mail, look 2.sword */
-    return (0);
-  if (!(msg = atoi(number)))
-    return (0);
-
-  if (GET_LEVEL(ch) < READ_LVL(board_type)) {
-    send_to_char(ch, "You try but fail to understand the holy words.\r\n");
-    return (1);
-  }
-  if (!num_of_msgs[board_type]) {
-    send_to_char(ch, "The board is empty!\r\n");
-    return (1);
-  }
-  if (msg < 1 || msg > num_of_msgs[board_type]) {
-    send_to_char(ch, "That message exists only in your imagination.\r\n");
-    return (1);
-  }
-#if NEWEST_AT_TOP
-  ind = num_of_msgs[board_type] - msg;
-#else
-  ind = msg - 1;
-#endif
-  if (MSG_SLOTNUM(board_type, ind) < 0 ||
-      MSG_SLOTNUM(board_type, ind) >= INDEX_SIZE) {
-    send_to_char(ch, "Sorry, the board is not working.\r\n");
-    log("SYSERR: Board is screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
-    return (1);
-  }
-  if (!(MSG_HEADING(board_type, ind))) {
-    send_to_char(ch, "That message appears to be screwed up.\r\n");
-    return (1);
-  }
-  if (!(msg_storage[MSG_SLOTNUM(board_type, ind)])) {
-    send_to_char(ch, "That message seems to be empty.\r\n");
-    return (1);
-  }
-  snprintf(buffer, sizeof(buffer), "Message %d : %s\r\n\r\n%s\r\n", msg,
-	  MSG_HEADING(board_type, ind),
-	  msg_storage[MSG_SLOTNUM(board_type, ind)]);
+  /*make the new node */
+  CREATE(mboard_type, struct board_memory, 1);
+  MEMORY_READER(mboard_type)=GET_IDNUM(ch);
+  MEMORY_TIMESTAMP(mboard_type)=MESG_TIMESTAMP(message);
+  MEMORY_NEXT(mboard_type)=NULL;
+  /* Let's make sure that we don't already have this memory recorded */
 
-  page_string(ch->desc, buffer, TRUE);
+  list=BOARD_MEMORY(thisboard,mem);
+  sflag=1;
+  while(list && sflag) {
+    if (MEMORY_READER(list) == MEMORY_READER(mboard_type) &&
+	MEMORY_TIMESTAMP(list) == MEMORY_TIMESTAMP(mboard_type)) {
+      /* nope, slot, reader, and timestamp equal, so already saved */
+      sflag=0;
+      
+    }
+    list=MEMORY_NEXT(list);
+    
+  }
+  
+  if(sflag) {
+    list=BOARD_MEMORY(thisboard,mem);
+    BOARD_MEMORY(thisboard,mem) = mboard_type;
+    MEMORY_NEXT(mboard_type)=list;
+  } else {
+    if(mboard_type) {
+    }
+  }
+  
+  /* before we print out the message, we may as well restore a human
+     readable timestamp. */
+  tmstr = (char *) asctime(localtime(&MESG_TIMESTAMP(message)));
+  *(tmstr + strlen(tmstr) - 1) = '\0';
+  sprintf(name,"%s",get_name_by_id(MESG_POSTER(message)));
+  sprintf(buf,"Message %d : %6.10s (%s) :: %s\r\n\r\n%s\r\n",
+	  arg,
+	  tmstr,
+	  CAP(name),
+	  MESG_SUBJECT(message) ? MESG_SUBJECT(message) : "No Subject",
+	  MESG_DATA(message) ? MESG_DATA(message) : "Looks like this message is empty.");
+  page_string(ch->desc, buf, 1);
+  /* really it's not so important to save after each view even if something WAS updated */
+  /* might be better to just save them with zone resets? */         
+  /* for now if sflag is triggered, we know that we added new memory */
+  if(sflag) {
+    save_board(thisboard);
+  }
+  return;
 
-  return (1);
 }
 
 
-int Board_remove_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board)
+int mesglookup(struct board_msg *message,struct char_data *ch, struct board_info *board)
 {
-  int ind, msg, slot_num;
-  char number[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH];
-  struct descriptor_data *d;
+  int mem;
+  struct board_memory *mboard_type;
+  mem = ((MESG_TIMESTAMP(message)%301 + MESG_POSTER(message)%301)%301);
 
-  one_argument(arg, number);
+  /* now, we check the mem slot. If its null, we return no, er.. 0..
+     if its full, we double check against the timestamp and reader -mislabled as poster, but who cares...
+     if they're not true, we go to the linked next slot, and repeat */
 
-  if (!*number || !is_number(number))
-    return (0);
-  if (!(msg = atoi(number)))
-    return (0);
-
-  if (!num_of_msgs[board_type]) {
-    send_to_char(ch, "The board is empty!\r\n");
-    return (1);
-  }
-  if (msg < 1 || msg > num_of_msgs[board_type]) {
-    send_to_char(ch, "That message exists only in your imagination.\r\n");
-    return (1);
-  }
-#if NEWEST_AT_TOP
-  ind = num_of_msgs[board_type] - msg;
-#else
-  ind = msg - 1;
-#endif
-  if (!MSG_HEADING(board_type, ind)) {
-    send_to_char(ch, "That message appears to be screwed up.\r\n");
-    return (1);
-  }
-  snprintf(buf, sizeof(buf), "(%s)", GET_NAME(ch));
-  if (GET_LEVEL(ch) < REMOVE_LVL(board_type) &&
-      !(strstr(MSG_HEADING(board_type, ind), buf))) {
-    send_to_char(ch, "You are not holy enough to remove other people's messages.\r\n");
-    return (1);
-  }
-  if (GET_LEVEL(ch) < MSG_LEVEL(board_type, ind)) {
-    send_to_char(ch, "You can't remove a message holier than yourself.\r\n");
-    return (1);
-  }
-  slot_num = MSG_SLOTNUM(board_type, ind);
-  if (slot_num < 0 || slot_num >= INDEX_SIZE) {
-    send_to_char(ch, "That message is majorly screwed up.\r\n");
-    log("SYSERR: The board is seriously screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
-    return (1);
-  }
-  for (d = descriptor_list; d; d = d->next)
-    if (STATE(d) == CON_PLAYING && d->str == &(msg_storage[slot_num])) {
-      send_to_char(ch, "At least wait until the author is finished before removing it!\r\n");
-      return (1);
-    }
-  if (msg_storage[slot_num])
-    free(msg_storage[slot_num]);
-  msg_storage[slot_num] = 0;
-  msg_storage_taken[slot_num] = 0;
-  if (MSG_HEADING(board_type, ind))
-    free(MSG_HEADING(board_type, ind));
-
-  for (; ind < num_of_msgs[board_type] - 1; ind++) {
-    MSG_HEADING(board_type, ind) = MSG_HEADING(board_type, ind + 1);
-    MSG_SLOTNUM(board_type, ind) = MSG_SLOTNUM(board_type, ind + 1);
-    MSG_LEVEL(board_type, ind) = MSG_LEVEL(board_type, ind + 1);
-  }
-  num_of_msgs[board_type]--;
-
-  send_to_char(ch, "Message removed.\r\n");
-  snprintf(buf, sizeof(buf), "$n just removed message %d.", msg);
-  act(buf, FALSE, ch, 0, 0, TO_ROOM);
-  Board_save_board(board_type);
+  mboard_type=BOARD_MEMORY(board,mem);
+  while(mboard_type) {
 
-  return (1);
+    if(MEMORY_READER(mboard_type)==GET_IDNUM(ch) &&
+       MEMORY_TIMESTAMP(mboard_type)==MESG_TIMESTAMP(message)) {
+      return 1;
+    } else {
+      mboard_type=MEMORY_NEXT(mboard_type);
+    }
+  }
+  return 0;
 }
 
 
-void Board_save_board(int board_type)
+void write_board_message(int board_vnum, struct char_data *ch, char *arg)
+     
 {
-  FILE *fl;
-  int i;
-  char *tmp1, *tmp2 = NULL;
+  struct board_info *thisboard=bboards;
+  struct board_msg *message;
 
-  if (!num_of_msgs[board_type]) {
-    remove(FILENAME(board_type));
+  if(IS_NPC(ch)) {
+    send_to_char(ch,"Orwellian police thwart your attempt at free speech.\r\n");
     return;
   }
-  if (!(fl = fopen(FILENAME(board_type), "wb"))) {
-    perror("SYSERR: Error writing board");
+  thisboard = locate_board(board_vnum);
+  
+  if (!thisboard) {
+    send_to_char(ch,"Error: Your board could not be found. Please report.\n");
+    log("Error in write_board_msg - board #%d", board_vnum);
     return;
   }
-  fwrite(&(num_of_msgs[board_type]), sizeof(int), 1, fl);
+  if (GET_LEVEL(ch) < WRITE_LVL(thisboard)) {
+    send_to_char(ch,"You are not holy enough to write on this board.\r\n");
 
-  for (i = 0; i < num_of_msgs[board_type]; i++) {
-    if ((tmp1 = MSG_HEADING(board_type, i)) != NULL)
-      msg_index[board_type][i].heading_len = strlen(tmp1) + 1;
-    else
-      msg_index[board_type][i].heading_len = 0;
+    return;
+  }
+  if(!*arg || !arg) {
+    sprintf(arg,"No Subject");
+  }
+  skip_spaces(&arg);
+  delete_doubledollar(arg);
+  arg[81] = '\0';
 
-    if (MSG_SLOTNUM(board_type, i) < 0 ||
-	MSG_SLOTNUM(board_type, i) >= INDEX_SIZE ||
-	(!(tmp2 = msg_storage[MSG_SLOTNUM(board_type, i)])))
-      msg_index[board_type][i].message_len = 0;
-    else
-      msg_index[board_type][i].message_len = strlen(tmp2) + 1;
 
-    fwrite(&(msg_index[board_type][i]), sizeof(struct board_msginfo), 1, fl);
-    if (tmp1)
-      fwrite(tmp1, sizeof(char), msg_index[board_type][i].heading_len, fl);
-    if (tmp2)
-      fwrite(tmp2, sizeof(char), msg_index[board_type][i].message_len, fl);
-  }
+  CREATE(message, struct board_msg, 1);
+  MESG_POSTER(message)=GET_IDNUM(ch);
+  MESG_TIMESTAMP(message)=time(0);
+  MESG_SUBJECT(message) = strdup(arg);
+  MESG_NEXT(message)=NULL;
+  MESG_DATA(message)=NULL;
+  BOARD_MNUM(thisboard) = MAX(BOARD_MNUM(thisboard) + 1,1);
 
-  fclose(fl);
-}
+  MESG_NEXT(message)=BOARD_MESSAGES(thisboard);
+  if(BOARD_MESSAGES(thisboard)) {
 
+  }
+  BOARD_MESSAGES(thisboard) = message;
+  send_to_char(ch,"Write your message.  (/s saves /h for help)\r\n");
+  act("$n starts to write a message.", TRUE, ch, 0, 0, TO_ROOM);
 
-void Board_load_board(int board_type)
-{
-  FILE *fl;
-  int i, len1, len2;
-  char *tmp1, *tmp2;
+  SET_BIT_AR(PLR_FLAGS(ch), PLR_WRITING);
+  string_write(ch->desc, &(MESG_DATA(message)),
+	       MAX_MESSAGE_LENGTH, board_vnum + BOARD_MAGIC, NULL);
+  return;
 
-  if (!(fl = fopen(FILENAME(board_type), "rb"))) {
-    if (errno != ENOENT)
-      perror("SYSERR: Error reading board");
+}
+
+void board_respond(int board_vnum, struct char_data *ch, int mnum){
+  struct board_info *thisboard=bboards;
+  struct board_msg *message,*other;
+  char number[MAX_STRING_LENGTH],buf[MAX_STRING_LENGTH];
+  int gcount=0;
+  
+  thisboard = locate_board(board_vnum);
+  
+  if (!thisboard) {
+    send_to_char(ch,"Error: Your board could not be found. Please report.\n");
+    log("Error in board_respond - board #%d", board_vnum);
     return;
   }
-  fread(&(num_of_msgs[board_type]), sizeof(int), 1, fl);
-  if (num_of_msgs[board_type] < 1 || num_of_msgs[board_type] > MAX_BOARD_MESSAGES) {
-    log("SYSERR: Board file %d corrupt.  Resetting.", board_type);
-    Board_reset_board(board_type);
+  if (GET_LEVEL(ch) < WRITE_LVL(thisboard)) {
+    send_to_char(ch,"You are not holy enough to write on this board.\r\n");
     return;
   }
-  for (i = 0; i < num_of_msgs[board_type]; i++) {
-    fread(&(msg_index[board_type][i]), sizeof(struct board_msginfo), 1, fl);
-    if ((len1 = msg_index[board_type][i].heading_len) <= 0) {
-      log("SYSERR: Board file %d corrupt!  Resetting.", board_type);
-      Board_reset_board(board_type);
+  
+  if (GET_LEVEL(ch) < READ_LVL(thisboard)) {
+    send_to_char(ch,"You are not holy enough to respond to this board.\r\n");
       return;
     }
-    CREATE(tmp1, char, len1);
-    fread(tmp1, sizeof(char), len1, fl);
-    MSG_HEADING(board_type, i) = tmp1;
+  if (mnum < 0 || mnum > BOARD_MNUM(thisboard)) {
+    send_to_char(ch,"You can only respond to an actual message.\r\n");
 
-    if ((MSG_SLOTNUM(board_type, i) = find_slot()) == -1) {
-      log("SYSERR: Out of slots booting board %d!  Resetting...", board_type);
-      Board_reset_board(board_type);
       return;
     }
-    if ((len2 = msg_index[board_type][i].message_len) > 0) {
-      CREATE(tmp2, char, len2);
-      fread(tmp2, sizeof(char), len2, fl);
-      msg_storage[MSG_SLOTNUM(board_type, i)] = tmp2;
-    } else
-      msg_storage[MSG_SLOTNUM(board_type, i)] = NULL;
+  
+  other=BOARD_MESSAGES(thisboard);
+  
+  /*locate message to be repsponded to */
+  
+  for(gcount=0;other && gcount != (mnum-1); gcount++)
+    other=MESG_NEXT(other);
+  
+  CREATE(message, struct board_msg, 1);
+  MESG_POSTER(message)=GET_IDNUM(ch);
+  MESG_TIMESTAMP(message)=time(0);
+  sprintf(buf,"Re: %s",MESG_SUBJECT(other));
+  MESG_SUBJECT(message)=strdup(buf);
+  MESG_NEXT(message)=MESG_PREV(message)=NULL;
+  MESG_DATA(message)=NULL;
+  BOARD_MNUM(thisboard) = BOARD_MNUM(thisboard) + 1;
+  MESG_NEXT(message) = BOARD_MESSAGES(thisboard);
+  if (BOARD_MESSAGES(thisboard)) {
+    MESG_PREV(BOARD_MESSAGES(thisboard)) = message;
   }
+  BOARD_MESSAGES(thisboard) = message;
 
-  fclose(fl);
-}
+  send_to_char(ch,"Write your message.  (/s saves /h for help)\r\n\r\n");
+  act("$n starts to write a message.", TRUE, ch, 0, 0, TO_ROOM);
 
+  if (!IS_NPC(ch)) {
+    SET_BIT_AR(PLR_FLAGS(ch), PLR_WRITING);
+  }
 
-/* When shutting down, clear all boards. */
-void Board_clear_all(void)
-{
-  int i;
+  /* don't need number anymore, so we'll reuse it. */
+  sprintf(number,"\t------- Quoted message -------\r\n%s\t------- End Quote -------\r\n",MESG_DATA(other));
+  MESG_DATA(message)=strdup(number);
+  ch->desc->backstr = strdup(number);
+  write_to_output(ch->desc,number);
 
-  for (i = 0; i < NUM_OF_BOARDS; i++)
-    Board_clear_board(i);
+  string_write(ch->desc, &(MESG_DATA(message)),
+	       MAX_MESSAGE_LENGTH, board_vnum + BOARD_MAGIC, NULL);
+  return;
 }
 
+struct board_info *locate_board(int board_vnum) {
+  struct board_info *thisboard = bboards;
 
-/* Clear the in-memory structures. */
-void Board_clear_board(int board_type)
-{
-  int i;
+  while(thisboard) {
+    if (BOARD_VNUM(thisboard) == board_vnum) {
+      return thisboard;
+    }
+    thisboard=BOARD_NEXT(thisboard);
 
-  for (i = 0; i < MAX_BOARD_MESSAGES; i++) {
-    if (MSG_HEADING(board_type, i))
-      free(MSG_HEADING(board_type, i));
-    if (msg_storage[MSG_SLOTNUM(board_type, i)])
-      free(msg_storage[MSG_SLOTNUM(board_type, i)]);
-    msg_storage_taken[MSG_SLOTNUM(board_type, i)] = 0;
-    memset((char *)&(msg_index[board_type][i]),0,sizeof(struct board_msginfo));
-    msg_index[board_type][i].slot_num = -1;
   }
-  num_of_msgs[board_type] = 0;
+  return NULL;
 }
 
 
-/* Destroy the on-disk and in-memory board. */
-void Board_reset_board(int board_type)
-{
-  Board_clear_board(board_type);
-  remove(FILENAME(board_type));
+void remove_board_msg(int board_vnum, struct char_data * ch, int arg) {
+  struct board_info *thisboard;
+  struct board_msg *cur;
+  struct descriptor_data *d;
+  int msgcount;
+  char buf[MAX_STRING_LENGTH+1];
+  
+  if(IS_NPC(ch)) {
+    send_to_char(ch,"Nuts.. looks like you forgot your eraser back in mobland...\r\n");
+    return;
+  }
+  thisboard = locate_board(board_vnum);
+  
+  if (!thisboard) {
+    send_to_char(ch,"Error: Your board could not be found. Please report.\n");
+    log("Error in Board_remove_msg - board #%d", board_vnum);
+    return;
+  }
+
+  cur=BOARD_MESSAGES(thisboard);
+  
+  if (arg < 1) {
+    send_to_char(ch,"You must specify the (positive) number of the message to be read!\r\n");
+    return;
+  }
+
+  if(PRF_FLAGGED(ch,PRF_VIEWORDER)) {
+    arg = BOARD_MNUM(thisboard) - arg + 1;
+  }
+  for(msgcount=arg;cur && msgcount!=1;msgcount--) {
+    cur=MESG_NEXT(cur);
+    
+  }
+  if(!cur) {
+    send_to_char(ch,"That message exists only in your imagination.\r\n");
+    return;
+  }
+  /* perform check for mesg in creation */
+  
+  for (d = descriptor_list; d; d = d->next) {
+    if (!d->connected && d->str == &(MESG_DATA(cur))) {
+      send_to_char(ch,"At least wait until the author is finished before removing it!\r\n");
+      return;
+    }
+  }
+  /* everything else is peachy, kill the message */
+  if(BOARD_MESSAGES(thisboard) == cur) {
+    if(MESG_NEXT(cur) != NULL) {
+      BOARD_MESSAGES(thisboard) = MESG_NEXT(cur);
+    } else {
+      BOARD_MESSAGES(thisboard) = NULL;
+    }
+  }
+  
+  /* due to the way these things work, these will never dereference nulls
+     because the unknown is based on cur */
+  
+  if(MESG_PREV(cur)) {
+    MESG_NEXT(MESG_PREV(cur)) = MESG_NEXT(cur);
+  }
+  
+  if(MESG_NEXT(cur)) {
+    MESG_PREV(MESG_NEXT(cur)) = MESG_PREV(cur);
+  }
+  free(cur);
+  cur = NULL;
+  BOARD_MNUM (thisboard) = BOARD_MNUM (thisboard) - 1;
+  send_to_char (ch,"Message removed.\r\n");
+  sprintf(buf, "$n just removed message %d.", arg);
+  act (buf, FALSE, ch, 0, 0, TO_ROOM);
+  save_board(thisboard);
+  return;
 }
+
+
diff -BbuprN -x '*.o' src/boards.h src-patched/boards.h
--- src/boards.h	2004-01-18 19:20:47.000000000 -0500
+++ src-patched/boards.h	2004-07-19 22:19:00.000000000 -0400
@@ -8,49 +8,85 @@
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ************************************************************************ */
 
-#define NUM_OF_BOARDS		4	/* change if needed! */
-#define MAX_BOARD_MESSAGES 	60      /* arbitrary -- change if needed */
+/* New Dynamic boards v2.4 -PjD (dughi@imaxx.net) */
+#define BOARD_DIRECTORY                "etc/boards"
 #define MAX_MESSAGE_LENGTH	4096	/* arbitrary -- change if needed */
 
-#define INDEX_SIZE	   ((NUM_OF_BOARDS*MAX_BOARD_MESSAGES) + 5)
-
 #define BOARD_MAGIC	1048575	/* arbitrary number - see modify.c */
 
-struct board_msginfo {
-   int	slot_num;     /* pos of message in "master index" */
-   char	*heading;     /* pointer to message's heading */
-   int	level;        /* level of poster */
-   int	heading_len;  /* size of header (for file write) */
-   int	message_len;  /* size of message text (for file write) */
+/* Provides individual message structure */
+/* doubly linked so forward or back is relatively simple */
+
+struct board_msg {
+  long poster;
+  time_t timestamp;
+  char *subject;
+  char *data;
+  struct board_msg *next;
+  struct board_msg *prev;
+};
+
+/* Defines what we require to generate a hash for lookup
+   of a message given a reader */
+
+struct board_memory {
+  int timestamp;
+  int reader;
+  struct board_memory *next;
 };
 
-struct board_info_type {
-   obj_vnum vnum;	/* vnum of this board */
+struct board_info {
    int	read_lvl;	/* min level to read messages on this board */
    int	write_lvl;	/* min level to write messages on this board */
    int	remove_lvl;	/* min level to remove messages from this board */
-   char	filename[50];	/* file to save this board to */
-   obj_rnum rnum;	/* rnum of this board */
+  int  num_messages;           /* num messages of this board */
+  int  vnum;
+  struct board_info *next;
+  struct board_msg *messages;
+  
+  /* why 301? why not?  It might not be the greatest, but if you really
+     know what a hash is, you'll realize that in this case, I didn't even
+     work on the algorithm, so it shouldn't make a bit of difference */
+  
+  struct board_memory *memory[301];
 };
 
-#define BOARD_VNUM(i) (board_info[i].vnum)
-#define READ_LVL(i) (board_info[i].read_lvl)
-#define WRITE_LVL(i) (board_info[i].write_lvl)
-#define REMOVE_LVL(i) (board_info[i].remove_lvl)
-#define FILENAME(i) (board_info[i].filename)
-#define BOARD_RNUM(i) (board_info[i].rnum)
-
-#define NEW_MSG_INDEX(i) (msg_index[i][num_of_msgs[i]])
-#define MSG_HEADING(i, j) (msg_index[i][j].heading)
-#define MSG_SLOTNUM(i, j) (msg_index[i][j].slot_num)
-#define MSG_LEVEL(i, j) (msg_index[i][j].level)
-
-int	Board_display_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
-int	Board_show_board(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
-int	Board_remove_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
-int	Board_write_message(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
-void	Board_save_board(int board_type);
-void	Board_load_board(int board_type);
-void	Board_reset_board(int board_type);
-void	Board_clear_board(int board_type);
-void	Board_clear_all(void);
+#define READ_LVL(i) (i->read_lvl)
+#define WRITE_LVL(i) (i->write_lvl)
+#define REMOVE_LVL(i) (i->remove_lvl)
+#define BOARD_MNUM(i) (i->num_messages)
+#define BOARD_VNUM(i) (i->vnum)
+#define BOARD_NEXT(i) (i->next)
+#define BOARD_MESSAGES(i) (i->messages)
+#define BOARD_MEMORY(i,j) (i->memory[j])
+
+#define MESG_POSTER(i) (i->poster)
+#define MESG_TIMESTAMP(i) (i->timestamp)
+#define MESG_SUBJECT(i) (i->subject)
+#define MESG_DATA(i) (i->data)
+#define MESG_NEXT(i) (i->next)
+#define MESG_PREV(i) (i->prev)
+
+#define MEMORY_TIMESTAMP(i) (i->timestamp)
+#define MEMORY_READER(i) (i->reader)
+#define MEMORY_NEXT(i) (i->next)
+
+void init_boards(void);
+struct board_info *create_new_board(int board_vnum);
+struct board_info *load_board(int board_vnum);
+int save_board(struct board_info *temp_board);
+void clear_boards();
+void clear_one_board(struct board_info *temp_board);
+int parse_message( FILE *fl, struct board_info *temp_board);
+void look_at_boards(void);
+void show_board(int board_vnum, struct char_data *ch);
+void board_display_msg(int board_vnum, struct char_data * ch, int arg);
+int mesglookup(struct board_msg *message,struct char_data *ch,
+	       struct board_info *board);
+
+void write_board_message(int board_vnum, struct char_data *ch, char *arg);
+void board_respond(int board_vnum, struct char_data *ch, int mnum);
+
+struct board_info *locate_board(int board_vnum);
+
+void remove_board_msg(int board_vnum, struct char_data * ch, int arg);
diff -BbuprN -x '*.o' src/comm.c src-patched/comm.c
--- src/comm.c	2004-05-27 21:36:14.000000000 -0400
+++ src-patched/comm.c	2004-07-19 22:19:00.000000000 -0400
@@ -169,7 +169,7 @@ void weather_and_time(int mode);
 int perform_alias(struct descriptor_data *d, char *orig, size_t maxlen);
 void clear_free_list(void);
 void free_messages(void);
-void Board_clear_all(void);
+void clear_boards(void);
 void free_social_messages(void);
 void free_mail_index(void);
 void Free_Invalid_List(void);
@@ -392,7 +392,7 @@ int main(int argc, char **argv)
     clear_free_list();		/* mail.c */
     free_mail_index();          /* mail.c */
     free_text_files();		/* db.c */
-    Board_clear_all();		/* boards.c */
+    clear_boards();             /* boards.c */
     free(cmd_sort_info);	/* act.informative.c */
     free_command_list();        /* act.informative.c */
     free_social_messages();	/* act.social.c */
diff -BbuprN -x '*.o' src/constants.c src-patched/constants.c
--- src/constants.c	2004-05-27 21:36:14.000000000 -0400
+++ src-patched/constants.c	2004-07-19 22:19:00.000000000 -0400
@@ -448,6 +448,7 @@ const char *item_types[] = {
   "WINDOW",
   "CONTROL",
   "PORTAL",
+  "BOARD",
   "\n"
 };
 
diff -BbuprN -x '*.o' src/db.c src-patched/db.c
--- src/db.c	2004-07-16 23:38:51.000000000 -0400
+++ src-patched/db.c	2004-07-19 22:19:00.000000000 -0400
@@ -30,6 +30,7 @@
 #include "diskio.h"
 #include "pfdefaults.h"
 #include "assemblies.h"
+#include "boards.h"
 
 
 /**************************************************************************
@@ -103,6 +104,8 @@ struct weather_data weather_info;	/* the
 struct player_special_data dummy_mob;	/* dummy spec area for mobs	*/
 struct reset_q_type reset_q;	/* queue of zones to be reset	 */
 
+extern struct board_info *boards; /* our boards */
+
 /* local functions */
 int check_bitvector_names(bitvector_t bits, size_t namecount, const char *whatami, const char *whatbits);
 int check_object_spell_number(struct obj_data *obj, int val);
@@ -635,6 +638,10 @@ void boot_db(void)
     log("    Mail boot failed -- Mail system disabled");
     no_mail = 1;
   }
+  
+  log("Booting boards system.");
+  init_boards();
+  
   log("Reading banned site and invalid-name list.");
   load_banned();
   Read_Invalid_List();
diff -BbuprN -x '*.o' src/genobj.c src-patched/genobj.c
--- src/genobj.c	2004-01-18 19:20:47.000000000 -0500
+++ src-patched/genobj.c	2004-07-19 22:19:00.000000000 -0400
@@ -10,7 +10,6 @@
 #include "structs.h"
 #include "utils.h"
 #include "db.h"
-#include "boards.h"
 #include "shop.h"
 #include "genolc.h"
 #include "genobj.h"
@@ -23,7 +22,6 @@ extern struct obj_data *obj_proto;
 extern struct obj_data *object_list;
 extern struct index_data *obj_index;
 extern struct zone_data *zone_table;
-extern struct board_info_type board_info[];
 extern struct shop_data *shop_index;
 extern zone_rnum top_of_zone_table;
 extern obj_rnum top_of_objt;
@@ -136,12 +134,6 @@ obj_rnum adjust_objects(obj_rnum refpt)
   }
 
   /*
-   * Renumber notice boards.
-   */
-  for (i = 0; i < NUM_OF_BOARDS; i++)
-    BOARD_RNUM(i) += (BOARD_RNUM(i) >= refpt);
-
-  /*
    * Renumber shop produce.
    */
   for (shop = 0; shop <= top_shop - top_shop_offset; shop++)
diff -BbuprN -x '*.o' src/interpreter.c src-patched/interpreter.c
--- src/interpreter.c	2004-07-16 23:38:51.000000000 -0400
+++ src-patched/interpreter.c	2004-07-19 22:19:00.000000000 -0400
@@ -180,6 +180,7 @@ ACMD(do_remort);
 ACMD(do_reply);
 ACMD(do_report);
 ACMD(do_rescue);
+ACMD(do_respond);
 ACMD(do_rest);
 ACMD(do_restore);
 ACMD(do_return);
@@ -489,6 +490,7 @@ cpp_extern const struct command_info cmd
   { "report"   , "repo"	, POS_RESTING , do_report   , 0, 0 },
   { "reroll"   , "rero"	, POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL },
   { "rescue"   , "resc"	, POS_FIGHTING, do_rescue   , 1, 0 },
+  { "respond"  , "resp" , POS_RESTING,  do_respond  , 1, 0 },
   { "restore"  , "resto"	, POS_DEAD    , do_restore  , LVL_GOD, 0 },
   { "return"   , "retu"	, POS_DEAD    , do_return   , 0, 0 },
   { "redit"    , "redit"	, POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_REDIT },
@@ -555,6 +557,7 @@ cpp_extern const struct command_info cmd
 
   { "value"    , "val"	, POS_STANDING, do_not_here , 0, 0 },
   { "version"  , "ver"	, POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION },
+  { "vieworder", "view" , POS_DEAD    , do_gen_tog  , 0, SCMD_VIEWORDER },
   { "visible"  , "vis"	, POS_RESTING , do_visible  , 1, 0 },
   { "vnum"     , "vnum"	, POS_DEAD    , do_vnum     , LVL_IMMORT, 0 },
   { "vstat"    , "vstat"	, POS_DEAD    , do_vstat    , LVL_IMMORT, 0 },
diff -BbuprN -x '*.o' src/interpreter.h src-patched/interpreter.h
--- src/interpreter.h	2004-05-27 21:36:15.000000000 -0400
+++ src-patched/interpreter.h	2004-07-19 22:23:46.000000000 -0400
@@ -140,6 +140,7 @@ struct alias_data {
 #define SCMD_CLS        22
 #define SCMD_AUTOSPLIT  23
 #define SCMD_AUTOSAC    24
+#define SCMD_VIEWORDER  25
 
 /* do_wizutil */
 #define SCMD_REROLL	0
diff -BbuprN -x '*.o' src/modify.c src-patched/modify.c
--- src/modify.c	2004-01-18 19:20:47.000000000 -0500
+++ src-patched/modify.c	2004-07-19 22:19:00.000000000 -0400
@@ -187,6 +187,10 @@ void string_add(struct descriptor_data *
           d->backstr = NULL;
           d->str = NULL;
           break;
+      case CON_PLAYING:
+	/* all CON_PLAYING are handled below in playing_string_cleanup */
+	break;
+		     
         default:
           log("SYSERR: string_add: Aborting write from unknown origin.");
           break;
@@ -242,23 +246,59 @@ void string_add(struct descriptor_data *
 
 void playing_string_cleanup(struct descriptor_data *d, int action)
 {
+  struct board_info *board;
+  struct board_msg *fore,*cur,*aft;
+  
   if (PLR_FLAGGED(d->character, PLR_MAILING)) {
     if (action == STRINGADD_SAVE && *d->str) {
       store_mail(d->mail_to, GET_IDNUM(d->character), *d->str);
       write_to_output(d, "Message sent!\r\n");
-    } else
+    } else {
       write_to_output(d, "Mail aborted.\r\n");
       free(*d->str);
       free(d->str);
     }
+  }
 
-  /*
-   * We have no way of knowing which slot the post was sent to so we can only give the message...
-   */
+  if(PLR_FLAGGED(d->character,PLR_WRITING)) {
     if (d->mail_to >= BOARD_MAGIC) {
-      Board_save_board(d->mail_to - BOARD_MAGIC);
-    if (action == STRINGADD_ABORT)
-      write_to_output(d, "Post not aborted, use REMOVE <post #>.\r\n");
+      if (action == STRINGADD_ABORT) {
+	/* find the message */
+	board = locate_board(d->mail_to - BOARD_MAGIC);
+	fore=cur=aft=NULL;
+	for(cur = BOARD_MESSAGES(board);cur;cur = aft) {
+	  aft=MESG_NEXT(cur);
+	  if(cur->data == *d->str) {
+	    if(BOARD_MESSAGES(board) == cur) {
+	      if(MESG_NEXT(cur) != NULL) {
+		BOARD_MESSAGES(board) = MESG_NEXT(cur);
+	      } else {
+		BOARD_MESSAGES(board) = NULL;
+	      }
+	    }
+	    if(fore) {
+	      MESG_NEXT(fore) = aft;
+	    }
+	    if(aft) {
+	      MESG_PREV(aft) = fore;
+	    }
+	    free(cur->subject);
+	    free(cur->data);
+	    free(cur);
+	    BOARD_MNUM(board)--;
+	    write_to_output(d,"Post aborted.\r\n");
+	    return;
+	  }
+	  fore=cur;
+	}
+	write_to_output(d,"Unable to find your message to delete it!\r\n");
+      } else {
+	write_to_output(d,"\r\nPost saved.\r\n");
+	save_board(locate_board(d->mail_to - BOARD_MAGIC));
+      }
+    }
+    
+    /* hm... I wonder what happens when you can't finish writing a note */
     }
 }
 
diff -BbuprN -x '*.o' src/oasis.h src-patched/oasis.h
--- src/oasis.h	2004-05-27 21:36:15.000000000 -0400
+++ src-patched/oasis.h	2004-07-19 22:22:06.000000000 -0400
@@ -38,7 +38,7 @@
 #define NUM_AFF_FLAGS		27
 #define NUM_ATTACK_TYPES	15
 
-#define NUM_ITEM_TYPES		29
+#define NUM_ITEM_TYPES		30
 #define NUM_ITEM_FLAGS		32
 #define NUM_ITEM_WEARS 		19
 #define NUM_APPLIES		27
diff -BbuprN -x '*.o' src/oedit.c src-patched/oedit.c
--- src/oedit.c	2004-05-27 21:46:56.000000000 -0400
+++ src-patched/oedit.c	2004-07-20 19:02:29.000000000 -0400
@@ -38,7 +38,7 @@ extern zone_rnum top_of_zone_table;
 extern struct shop_data *shop_index;
 extern struct attack_hit_type attack_hit_text[];
 extern struct spell_info_type spell_info[];
-extern struct board_info_type board_info[];
+extern struct board_info *bboards;
 extern struct descriptor_data *descriptor_list;
 extern const char *material_names[];
 
@@ -566,6 +566,9 @@ void oedit_disp_val1_menu(struct descrip
   case ITEM_PORTAL:
     write_to_output(d, "Which room number is the destination? : ");
     break;
+  case ITEM_BOARD:
+    write_to_output(d, "Enter the minimum level to read this board: ");
+    break;
   default:
     oedit_disp_val5_menu(d);
   }
@@ -609,6 +612,9 @@ void oedit_disp_val2_menu(struct descrip
   case ITEM_FOUNTAIN:
     write_to_output(d, "Initial drink units : ");
     break;
+  case ITEM_BOARD:
+    write_to_output(d, "Minimum level to write: ");
+    break;
   default:
     oedit_disp_val5_menu(d);
   }
@@ -654,6 +660,9 @@ void oedit_disp_val3_menu(struct descrip
   case ITEM_PORTAL:
     write_to_output(d, "Vnum of the key to unlock portal (-1 for no key) : ");
     break;
+  case ITEM_BOARD:
+    write_to_output(d, "Minimum level to remove messages: ");
+    break;
   default:
     oedit_disp_val5_menu(d);
   }
@@ -879,6 +888,7 @@ void oedit_parse(struct descriptor_data 
 {
   int number, max_val, min_val;
   char *oldtext = NULL;
+  struct board_info *tmp;
 
   switch (OLC_MODE(d)) {
 
@@ -894,6 +904,15 @@ void oedit_parse(struct descriptor_data 
 	write_to_output(d, "Object saved to disk.\r\n");
       } else
         write_to_output(d, "Object saved to memory.\r\n");
+      if(GET_OBJ_TYPE(OLC_OBJ(d)) == ITEM_BOARD) {
+	if((tmp=locate_board(GET_OBJ_VNUM(OLC_OBJ(d)))) != NULL) {
+	  save_board(tmp);
+	} else {
+	  tmp = create_new_board(GET_OBJ_VNUM(OLC_OBJ(d)));
+	  BOARD_NEXT(tmp) = bboards;
+	  bboards = tmp;
+	}
+      }
       /* Fall through. */
     case 'n':
     case 'N':
diff -BbuprN -x '*.o' src/spec_assign.c src-patched/spec_assign.c
--- src/spec_assign.c	2004-03-30 20:50:25.000000000 -0500
+++ src-patched/spec_assign.c	2004-07-19 22:21:24.000000000 -0400
@@ -36,7 +36,6 @@ SPECIAL(snake);
 SPECIAL(thief);
 SPECIAL(magic_user);
 SPECIAL(bank);
-SPECIAL(gen_board);
 SPECIAL(lyrzaxyn);
 SPECIAL(azimer);
 SPECIAL(dziak);
@@ -256,11 +255,6 @@ void assign_mobiles(void)
 /* assign special procedures to objects */
 void assign_objects(void)
 {
-  ASSIGNOBJ(3096, gen_board);	/* social board */
-  ASSIGNOBJ(3097, gen_board);	/* freeze board */
-  ASSIGNOBJ(3098, gen_board);	/* immortal board */
-  ASSIGNOBJ(3099, gen_board);	/* mortal board */
-
   ASSIGNOBJ(3034, bank);	/* atm */
   ASSIGNOBJ(3036, bank);	/* cashcard */
 }
diff -BbuprN -x '*.o' src/structs.h src-patched/structs.h
--- src/structs.h	2004-07-16 23:38:51.000000000 -0400
+++ src-patched/structs.h	2004-07-19 22:19:00.000000000 -0400
@@ -275,6 +275,7 @@
 #define PRF_AUTOSPLIT   28 /* Split gold with group			*/
 #define PRF_FULL_EXIT   29 /* Shows full autoexit details		*/
 #define PRF_AUTOSAC     30 /* Sacrifice a corpse 			*/
+#define PRF_VIEWORDER   31 /* if you want to see the newest first */
 
 /* Player autoexit levels: used as an index to exitlevels           */
 #define EXIT_OFF        0       /* Autoexit off                     */
@@ -415,6 +416,7 @@
 #define ITEM_WINDOW    26               /* Item is a vehicle window     */
 #define ITEM_CONTROL   27               /* Item is a vehicle control    */
 #define ITEM_PORTAL    28               /* Item is a portal	        */
+#define ITEM_BOARD     29               /* Item is a message board */
 
 
 /* Take/Wear flags: used by obj_data.obj_flags.wear_flags */
diff -BbuprN -x '*.o' src/utils.c src-patched/utils.c
--- src/utils.c	2004-01-18 19:20:47.000000000 -0500
+++ src-patched/utils.c	2004-07-19 22:19:00.000000000 -0400
@@ -736,3 +736,173 @@ int room_is_dark(room_rnum room)
 
   return (FALSE);
 }
+
+/* General use directory functions & structures. Required due to */
+/* various differences between directory handling code on        */
+/* different OS'es.  Needs solid testing though.                 */
+/* Added by Dynamic Boards v2.4 - PjD (dughi@imaxx.net)          */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef CIRCLE_WINDOWS
+#include <direct.h>
+/* I shouldn't need to include the following line, right? */
+#include <windows.h>
+
+int xdir_scan(const char *dir_name, struct xap_dir *xapdirp) {
+  HANDLE dirhandle;
+  int i;
+  
+  dirhandle = FindFirstFile(dir_name, &wtfd);
+  
+  xapdirp->current = xapdirp->total=-1;
+  if(dirhandle == INVALID_HANDLE_VALUE) {
+    return -1;
+  }
+  
+  (xapdirp->total)++;
+  while(FindNextFile(dirhandle, &wtfd)) {
+    (xapdirp->total)++;
+  }
+  
+  if(GetLastError() != ERROR_NO_MORE_FILES) {
+    xapdirp->total = -1;
+    return -1;
+  }
+  
+  FindClose(dirhandle);
+  dirhandle = FindFirstFile(dir_name, &wtfd);
+  
+  xapdirp->namelist = (char **) malloc(sizeof(char *) * total);
+	      
+  for(i =0; i < total && FindNextFile(dirhandle, &wtfd);i++) {
+    xapdirp->namelist[i] = strdup(wtfd.cFileName);
+  }
+  FindClose(dirhandle);
+  
+  xapdirp->current=0;
+  return xapdirp->total;
+}
+
+char *xdir_get_name(struct xap_dir *xd,int i) {
+  return xd->namelist[i];
+  }
+
+char *xdir_get_next(struct xap_dir *xd) {
+  if(++(xd->current) >= xd->total) {
+    return NULL;
+  }
+  return xd->namelist[xd->current-1];
+}
+
+#else
+#include <dirent.h>
+#include <unistd.h>
+
+int xdir_scan(const char *dir_name, struct xap_dir *xapdirp) {
+  xapdirp->total = scandir(dir_name,&(xapdirp->namelist),0,alphasort);
+  xapdirp->current = 0;
+  
+  return(xapdirp->total);
+}
+
+char *xdir_get_name(struct xap_dir *xd,int i) {
+  return xd->namelist[i]->d_name;
+}
+
+char *xdir_get_next(struct xap_dir *xd) {
+  if(++(xd->current) >= xd->total) {
+    return NULL;
+  }
+  return xd->namelist[xd->current-1]->d_name;
+}
+
+#endif
+
+void xdir_close(struct xap_dir *xd) {
+  int i;
+  for(i=0;i < xd->total;i++) {
+    free(xd->namelist[i]);
+  }
+  free(xd->namelist);
+  xd->namelist = NULL;
+  xd->current = xd->total = -1;
+}
+
+int xdir_get_total(struct xap_dir *xd) {
+  return xd->total;
+}
+
+int insure_directory(char *path, int isfile) {
+  char *chopsuey = strdup(path);
+  char *p;
+#ifdef CIRCLE_WINDOWS
+  struct _stat st;
+#else
+  struct stat st;
+#endif
+  
+  extern int errno;
+  
+  // if it's a file, remove that, we're only checking dirs;
+  if(isfile) {
+    if(!(p=strrchr(path,'/'))) {
+      free(chopsuey);
+      return 1;
+    }
+    *p = '\0';
+  }
+  
+  // remove any trailing /'s
+  
+  while(chopsuey[strlen(chopsuey)-1] == '/') {
+    chopsuey[strlen(chopsuey) -1 ] = '\0';
+  }
+  
+  // check and see if it's already a dir
+  
+  //#ifdef CIRCLE_WINDOWS
+  // if(!_stat(chopsuey,&st) && S_ISDIR(st.st_mode)) {
+  //#else
+    if(!stat(chopsuey,&st) && S_ISDIR(st.st_mode)) {
+      //#endif
+      free(chopsuey);
+      return 1;
+    }
+    
+    char *temp = strdup(chopsuey);
+    if((p = strrchr(temp,'/')) != NULL) {
+      *p = '\0';
+    }
+    if(insure_directory(temp,0) &&
+       
+#ifdef CIRCLE_WINDOWS
+       !_mkdir(chopsuey)) {
+#else
+      !mkdir(chopsuey, S_IRUSR | S_IWRITE | S_IEXEC | S_IRGRP | S_IXGRP |
+	     S_IROTH | S_IXOTH)) {
+#endif
+      free(temp);
+      free(chopsuey);
+      return 1;
+    }
+    
+    if(errno == EEXIST &&
+#ifdef CIRCLE_WINDOWS
+       !_stat(temp,&st) &&
+#else
+       !stat(temp,&st)
+#endif
+       && S_ISDIR(st.st_mode)) {
+      free(temp);
+      free(chopsuey);
+      return 1;
+    } else {
+      free(temp);
+      free(chopsuey);
+      return 1;
+    }
+  }
+  
+  
diff -BbuprN -x '*.o' src/utils.h src-patched/utils.h
--- src/utils.h	2004-07-16 23:38:51.000000000 -0400
+++ src-patched/utils.h	2004-07-19 22:19:00.000000000 -0400
@@ -672,3 +672,31 @@ void	update_pos(struct char_data *victim
 #define GET_REMORT_THREE(ch)     ((ch)->player.was_class2)
 #define GET_REMORT_LEVEL(ch)     ((ch)->player.remort_level)
      
+/* General use directory functions & structures. Required due to */
+/* various differences between directory handling code on        */
+/* different OS'es.  Needs solid testing though.                 */
+/* Added by Dynamic Boards v2.4 - PjD (dughi@imaxx.net)          */
+
+#ifdef CIRCLE_UNIX
+#include <dirent.h>
+
+struct xap_dir {
+  int total, current;
+  struct dirent **namelist;
+};
+
+#elif defined(CIRCLE_WINDOWS)
+
+struct xap_dir {
+  int total,current;
+  char **namelist;
+};
+
+#endif
+
+int xdir_scan(const char *dir_name, struct xap_dir *xapdirp);
+int xdir_get_total(struct xap_dir *xd);
+char *xdir_get_name(struct xap_dir *xd, int num);
+char *xdir_next(struct xap_dir *xd);
+void xdir_close(struct xap_dir *xd);
+int insure_directory(char *path, int isfile);
